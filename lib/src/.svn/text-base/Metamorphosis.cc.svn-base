/*=========================================================================
 
 
 Author: Laurent Risser, Francois-Xavier Vialard
 
 Disclaimer: This software has been developed for research purposes only, and hence should 
 not be used as a diagnostic tool. In no event shall the authors or distributors
 be liable to any direct, indirect, special, incidental, or consequential 
 damages arising of the use of this software, its documentation, or any 
 derivatives thereof, even if the authors have been advised of the possibility 
 of such damage. 
 
 
 =========================================================================*/

#include <Metamorphosis.h>

///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///                                   CONSTRUCTOR AND DESTRUCTOR
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LDM_Metamorphosis::LDM_Metamorphosis(void){
  int i;
  
  //default parameters
  epsilon=0.2;
  iteration_nb=10;
  NbTimeSubdiv=10;
  Max_GL_Update=4;
  MaxVelocityUpdate=0.4;  //rem: Delta Voxels = 1
  weight1=100.; sigmaX1=1.;  sigmaY1=1.;  sigmaZ1=1.;
  weight2=0.;   sigmaX2=-1.; sigmaY2=-1.; sigmaZ2=-1.;
  weight3=0.;   sigmaX3=-1.; sigmaY3=-1.; sigmaZ3=-1.;
  weight4=0.;   sigmaX4=-1.; sigmaY4=-1.; sigmaZ4=-1.;
  weight5=0.;   sigmaX5=-1.; sigmaY5=-1.; sigmaZ5=-1.;
  weight6=0.;   sigmaX6=-1.; sigmaY6=-1.; sigmaZ6=-1.;
  weight7=0.;   sigmaX7=-1.; sigmaY7=-1.; sigmaZ7=-1.;
  TranslatEstim=0;
  Margin=0;
  WghtVelField=0.001; //previously 1
  RefMaxGrad=-1.;
  Ref_GL_Grad=-1;
  GreyLevAlign=0;
  GLA_Padding_Src=-1.;
  GLA_Padding_Trg=-1.;
  FlowLength=0;
  DetJacobian=0;
  FinalDefVec=0;
  FinalDefInvVec=0;
  strcpy(PrefixInputs,"Null");
  strcpy(PrefixOutputs,"Outputs");
  strcpy(MaskFile,"Null");
  strcpy(SourceFile,"Null");
  strcpy(TargetFile,"Null");
  MeasureTypicAmp=0;
  World_Target2Template[0][0]=1; World_Target2Template[0][1]=0;   World_Target2Template[0][2]=0;    World_Target2Template[0][3]=0;   
  World_Target2Template[1][0]=0; World_Target2Template[1][1]=1;   World_Target2Template[1][2]=0;    World_Target2Template[1][3]=0;   
  World_Target2Template[2][0]=0; World_Target2Template[2][1]=0;   World_Target2Template[2][2]=1;    World_Target2Template[2][3]=0;   
  World_Target2Template[3][0]=0; World_Target2Template[3][1]=0;   World_Target2Template[3][2]=0;    World_Target2Template[3][3]=1; 
  x_mm=1;
  y_mm=1;
  y_mm=1;
  lambda=1;
  CharacScaleUpdates=1;
}

LDM_Metamorphosis::~LDM_Metamorphosis(void){}


///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///                        SUB-FUNCTIONS TO PERFORM THE REGISTRATION
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


///initiate the gradient descent (Beg 2005) for the current 3D image of the 4D time sequence
void LDM_Metamorphosis::ReadAndTreatInputImages(void){
  int x, y, z;
  int DistClosestEdge;
  int i,j;
  double mean1,mean2,std1,std2;
  ScalarField Mask;
  float tempQuat[4][4];
  float World_Template2Target[4][4];

  
  //2) READ INPUTS
  //2.1) read files
  ImTemplate.Read(this->SourceFile);
  ImTarget.Read(this->TargetFile);
    
  //2.2) check whether  3D or 2D images are opened
  if (ImTemplate.NT>1) cout << "Source image " << " depends on time!!!";
  if (ImTarget.NT>1) cout << "Target image " << " depends on time!!!";
    
  //2.5) variables containing the size of the image
  this->NX=ImTemplate.NX;
  this->NY=ImTemplate.NY;
  this->NZ=ImTemplate.NZ;
  this->NT=1;
  
  cout << "Image size: " << this->NX << "*" << this->NY << "*" << this->NZ << " (target: " << this->ImTarget.NX <<  "*"  <<  this->ImTarget.NY  <<  "*"  << this->ImTarget.NZ  << ")\n";
  
  
  //2.6) compute the quaternion to convert target coordinates into template coordinates
  
  //... compute the quaternion
  invert_4t4quaternion(this->World_Target2Template,World_Template2Target);
  
  mult_quat4t4mat_quat4t4mat(World_Template2Target,ImTemplate.Image2World,tempQuat);
  mult_quat4t4mat_quat4t4mat(ImTarget.World2Image,tempQuat,this->Template2TargetCoord);
  
  //... show the Template to Target quaternion in image spaces
  cout << endl;
  cout << "Template to target:" << endl;
  for (i=0;i<4;i++){
    for (j=0;j<4;j++){
      cout << this->Template2TargetCoord[i][j] << " ";
    }
    cout << endl;
  }
  
  
  
  //2.7 compute the voxels size in mm
  this->x_mm=sqrt(ImTemplate.Image2World[0][0]*ImTemplate.Image2World[0][0]+ImTemplate.Image2World[0][1]*ImTemplate.Image2World[0][1]+ImTemplate.Image2World[0][2]*ImTemplate.Image2World[0][2]);
  this->y_mm=sqrt(ImTemplate.Image2World[1][0]*ImTemplate.Image2World[1][0]+ImTemplate.Image2World[1][1]*ImTemplate.Image2World[1][1]+ImTemplate.Image2World[1][2]*ImTemplate.Image2World[1][2]);
  this->z_mm=sqrt(ImTemplate.Image2World[2][0]*ImTemplate.Image2World[2][0]+ImTemplate.Image2World[2][1]*ImTemplate.Image2World[2][1]+ImTemplate.Image2World[2][2]*ImTemplate.Image2World[2][2]);
  
  cout << endl;
  cout << "Template image resolution: " << this->x_mm << " "  << this->y_mm << " "  << this->z_mm << endl;
  
  //2.8 convert the sigmas from mm to voxels
  this->sigmaX1=this->sigmaX1/x_mm;  this->sigmaY1=this->sigmaY1/y_mm;  this->sigmaZ1=this->sigmaZ1/z_mm;
  this->sigmaX2=this->sigmaX2/x_mm;  this->sigmaY2=this->sigmaY2/y_mm;  this->sigmaZ2=this->sigmaZ2/z_mm;
  this->sigmaX3=this->sigmaX3/x_mm;  this->sigmaY3=this->sigmaY3/y_mm;  this->sigmaZ3=this->sigmaZ3/z_mm;
  this->sigmaX4=this->sigmaX4/x_mm;  this->sigmaY4=this->sigmaY4/y_mm;  this->sigmaZ4=this->sigmaZ4/z_mm;
  this->sigmaX5=this->sigmaX5/x_mm;  this->sigmaY5=this->sigmaY5/y_mm;  this->sigmaZ5=this->sigmaZ5/z_mm;
  this->sigmaX6=this->sigmaX6/x_mm;  this->sigmaY6=this->sigmaY6/y_mm;  this->sigmaZ6=this->sigmaZ6/z_mm;
  this->sigmaX7=this->sigmaX7/x_mm;  this->sigmaY7=this->sigmaY7/y_mm;  this->sigmaZ7=this->sigmaZ7/z_mm;
  
  
  //3) CREATE THE MASK
  if (strcmp(this->MaskFile,"Null")!=0){
    //read the mask
    Mask.Read(this->MaskFile);
    
    if ((ImTemplate.NX!=Mask.NX)) cout << "The image(s) and the mask do not have the same size!!!";
    if ((ImTemplate.NY!=Mask.NY)) cout << "The image(s) and the mask do not have the same size!!!";
    if ((ImTemplate.NZ!=Mask.NZ)) cout << "The image(s) and the mask do not have the same size!!!";
    
    //mask the image
    for(z=0;z<this->NZ;z++) for(y=0;y<this->NY;y++) for(x=0;x<this->NX;x++) if (Mask.G(x,y,z)<0.001)
      this->ImTemplate.P(0.,x,y,z);
     
    for(z=0;z<this->NZ;z++) for(y=0;y<this->NY;y++) for(x=0;x<this->NX;x++) if (Mask.G(x,y,z)<0.001)
      this->ImTarget.P(0.,x,y,z);
  }  
  
  //4) LINEAR ALIGNMENT OF THE GREY LEVELS OF ImTarget ON THOSE OF ImTemplate
  if (this->GreyLevAlign==1){
    float PaddingValue;
    int NbVoxelsOK;
    PaddingValue=10;
  
    //compute mean and std dev of the source and target images
    mean1=0.;
    NbVoxelsOK=0;
    for (z = this->Margin; z < this->NZ-this->Margin; z++)  for (y = this->Margin; y < this->NY-this->Margin; y++) for (x = this->Margin; x < this->NX-this->Margin; x++) if (this->ImTemplate.G(x,y,z)>GLA_Padding_Src){
      mean1+=(double)this->ImTemplate.G(x,y,z);
      NbVoxelsOK++;
    }
    mean1/=(double)(NbVoxelsOK);
    
    mean2=0.;
    NbVoxelsOK=0;
    for (z = this->Margin; z < this->ImTarget.NZ-this->Margin; z++)  for (y = this->Margin; y < this->ImTarget.NY-this->Margin; y++) for (x = this->Margin-this->Margin; x < this->ImTarget.NX; x++) if (this->ImTarget.G(x,y,z)>GLA_Padding_Trg){
      mean2+=(double)this->ImTarget.G(x,y,z);
      NbVoxelsOK++;
    }
    mean2/=(double)(NbVoxelsOK);
    
    std1=0.;
    NbVoxelsOK=0;
    for (z = this->Margin; z < this->NZ-this->Margin; z++)  for (y = this->Margin; y < this->NY-this->Margin; y++) for (x = this->Margin; x < this->NX-this->Margin; x++) if (this->ImTemplate.G(x,y,z)>GLA_Padding_Src){
      std1+=pow((double)this->ImTemplate.G(x,y,z)-mean1,2.);
      NbVoxelsOK++;
    }
    std1/=(double)(NbVoxelsOK);
    std1=sqrt(std1);
    
    std2=0.;
    NbVoxelsOK=0;
    for (z = this->Margin; z < this->ImTarget.NZ-this->Margin; z++)  for (y = this->Margin; y < this->ImTarget.NY-this->Margin; y++) for (x = this->Margin; x < this->ImTarget.NX-this->Margin; x++) if (this->ImTarget.G(x,y,z)>GLA_Padding_Trg){
      std2+=pow((double)this->ImTarget.G(x,y,z)-mean2,2.);
      NbVoxelsOK++;
    }
    std2/=(double)(NbVoxelsOK);
    std2=sqrt(std2);
    
    cout << "Template: mean=" << mean1 << ", stddev=" << std1 << ".    Target: mean=" << mean2 << ", stddev=" << std2 << "\n";
    
    
    for (z = 0; z < this->ImTarget.NZ; z++)  for (y = 0; y < this->ImTarget.NY; y++) for (x = 0; x < this->ImTarget.NX; x++)
      this->ImTarget.P((this->ImTarget.G(x,y,z)-(float)mean2)*(((float)std1)/((float)std2))+(float)mean1,x,y,z);
    
    
    for (z = 0; z < this->ImTarget.NZ; z++)  for (y = 0; y < this->ImTarget.NY; y++) for (x = 0; x < this->ImTarget.NX; x++)
      if ((this->ImTarget.G(x,y,z)<(GLA_Padding_Trg-(float)mean2)*(((float)std1)/((float)std2))+(float)mean1)||(this->ImTarget.G(x,y,z)<GLA_Padding_Src))
        this->ImTarget.P(0.,x,y,z);
  }
  //this->ImTarget.Write("TrgNew.nii",this->SourceFile);
  //this->ImTemplate.Write("SrcNew.nii",this->SourceFile);
  
  
  //5) normalize the weight of the different scales
  float sumWgt;
  
  if (fabs(this->weight1)>0.01){
    sumWgt=this->weight1+this->weight2+this->weight3+this->weight4+this->weight5+this->weight6+this->weight7;
    
    this->weight1/=sumWgt;
    this->weight2/=sumWgt;
    this->weight3/=sumWgt;
    this->weight4/=sumWgt;
    this->weight5/=sumWgt;
    this->weight6/=sumWgt;
    this->weight7/=sumWgt;
  }

}


///allocate all variables used for the gradient descent (Beg 2005) of the current 3D image from the treated 4D time sequence.
///Compute also the dimension of the scalar and vector fields in use
void LDM_Metamorphosis::AllocateAllVariables(void){
  int i,j,k;
  
  //time step between two subdivision
  this->DeltaTimeSubdiv=1./(static_cast<float>(NbTimeSubdiv-1));
  
  //4) initiate the velocity field
  //... velocity field
  //    -->  VelocityField.G(0,x,y,z,i)= direction ex of the vector at (x,y,z)
  //    -->  VelocityField.G(1,x,y,z,i)= direction ey of the vector at (x,y,z)
  //    -->  VelocityField.G(2,x,y,z,i)= direction ez of the vector at (x,y,z)
  //    -->  where n is the id of the velocity field
  if (strcmp(PrefixInputs,"Null")!=0)
    this->LoadVelocityFields(PrefixInputs);  //NbTimeSubdiv should be checked
  else
    this->VelocityField.CreateVoidField(this->NX,this->NY,this->NZ,this->NbTimeSubdiv);
  
  //... forward mapping
  //    -->  ForwardMapping.G(0,x,y,z,i) = coordinate x at time i corresponding to (x,y,z) at time 0
  //    -->  ForwardMapping.G(1,x,y,z,i) = coordinate y at time i corresponding to (x,y,z) at time 0
  //    -->  ForwardMapping.G(2,x,y,z,i) = coordinate z at time i corresponding to (x,y,z) at time 0
  this->ForwardMapping.CreateVoidField(this->NX,this->NY,this->NZ,this->NbTimeSubdiv);
  
  //... backward mapping
  //    -->  BackwardMapping.G(0,x,y,z,i) = coordinate x at time i corresponding to (x,y,z) at time 1
  //    -->  BackwardMapping.G(1,x,y,z,i) = coordinate y at time i corresponding to (x,y,z) at time 1
  //    -->  BackwardMapping.G(2,x,y,z,i) = coordinate z at time i corresponding to (x,y,z) at time 1
  this->BackwardMapping.CreateVoidField(this->NX,this->NY,this->NZ,this->NbTimeSubdiv);
  
  this->Tmp3DMapping.CreateVoidField(this->NX,this->NY,this->NZ);
  
  //... temporary image transformed using the forward mapping from time 0
  //    -->  J0.G(x,y,z) = gray level of the transformed image J0 at (x,y,z)
  this->J0.CreateVoidField(this->NX,this->NY,this->NZ);
  
  //... temporary image transformed using the backward mapping from time 1
  //    -->  J1.G(x,y,z) = gray level of the transformed image J1 at (x,y,z)
  this->J1.CreateVoidField(this->NX,this->NY,this->NZ);
  
  //... Image evolution
  this->ImEvo.CreateVoidField(this->NX,this->NY,this->NZ,this->NbTimeSubdiv);
  this->GradImEvo.CreateVoidField(this->NX,this->NY,this->NZ,this->NbTimeSubdiv);
  this->TempImage.CreateVoidField(this->NX,this->NY,this->NZ);
  
  //... gradient of J
  //    -->  GradJ.G(0,x,y,z)= gradient of J0 in direction ex at (x,y,z)
  //    -->  GradJ.G(1,x,y,z)= gradient of J0 in direction ey at (x,y,z)
  //    -->  GradJ.G(2,x,y,z)= gradient of J0 in direction ez at (x,y,z)
  this->GradJ.CreateVoidField(this->NX,this->NY,this->NZ);
  
  //... determinent of the Jacobians  
  //    -->  Jacobians.G(x,y,z)= determinant of the jacobian at (x,y,z)
  this->DetJacobians.CreateVoidField(this->NX,this->NY,this->NZ);
  
  //... Energy Gradient
  //    -->  GradE.G(0,i,x,y,z) = Energy gradient at time i in direction ex at (x,y,z)
  //    -->  GradE.G(1,i,x,y,z) = Energy gradient at time i in direction ey at (x,y,z)
  //    -->  GradE.G(2,i,x,y,z) = Energy gradient at time i in direction ez at (x,y,z)
  this->GradE.CreateVoidField(this->NX,this->NY,this->NZ,this->NbTimeSubdiv);
  
  
  //7) Initiate the class to smooth the images
  FFTconvolver.InitiateConvolver(this->NX,this->NY,this->NZ,this->weight1,this->sigmaX1,this->sigmaY1,this->sigmaZ1,this->weight2,this->sigmaX2,this->sigmaY2,this->sigmaZ2,this->weight3,this->sigmaX3,this->sigmaY3,this->sigmaZ3,this->weight4,this->sigmaX4,this->sigmaY4,this->sigmaZ4,this->weight5,this->sigmaX5,this->sigmaY5,this->sigmaZ5,this->weight6,this->sigmaX6,this->sigmaY6,this->sigmaZ6,this->weight7,this->sigmaX7,this->sigmaY7,this->sigmaZ7);

  
  
}



///Compute the energy gradients
void LDM_Metamorphosis::ComputeEnergyGradient(int timeSubdiv,int ItNb){
  int x,y,z,i;
  float temp,maxLoc;
  
  
  
  //1) INIT
  //if testing the weights
  if (ItNb==-1) this->CharacScaleUpdates=1;
  
  //if first iteration
  if (ItNb==0){
    this->CharacScaleUpdates=0;
    
    for (i=0;i<3;i++){
      //compute the scalar field (one dimension out of the vector field) to smooth
      for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++){
        if ((z<this->Margin)||(z>this->NZ-this->Margin-1)||(y<this->Margin)||(y>this->NY-this->Margin-1)||(x<this->Margin)||(x>this->NX-this->Margin-1))
          temp=0;
        else 
          temp=(this->J0.G(x,y,z) - this->J1.G(x,y,z)) * this->GradJ.G(i,x,y,z);
        this->FFTconvolver.P(temp,x,y,z);
      }
      
      //smooth the scalar field
      FFTconvolver.Convolution();
      
      //set the gradient of Energy...
      //contribution to grad E
      maxLoc=0;
      for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
        if (fabs(FFTconvolver.G(x,y,z))>maxLoc) maxLoc=fabs(FFTconvolver.G(x,y,z));
      
      this->CharacScaleUpdates+=maxLoc*maxLoc;
    }
    
    this->CharacScaleUpdates=sqrt(this->CharacScaleUpdates);
   
    if (this->CharacScaleUpdates==0){
      cout << "It appears that the registered images are the same or the smoothing kernel is far too large!" << endl;
      this->CharacScaleUpdates=1;
    }
  }
 
  //2) GRADIENT OF VELOCITY

  //loop on the vector directions (x,y,z)
  for (i=0;i<3;i++){
    //compute the scalar field (one dimension out of the vector field) to smooth
    for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++){
      if ((z<this->Margin)||(z>this->NZ-this->Margin-1)||(y<this->Margin)||(y>this->NY-this->Margin-1)||(x<this->Margin)||(x>this->NX-this->Margin-1))
        temp=0;
      else 
        temp=(this->J0.G(x,y,z) - this->J1.G(x,y,z)) * this->GradJ.G(i,x,y,z);
      this->FFTconvolver.P(temp,x,y,z);
    }
    
    //smooth the scalar field
    FFTconvolver.Convolution();
    
    //set the gradient of Energy...
    //contribution to grad E
    for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
      this->GradE.P(-this->VelocityField.G(i,x,y,z,timeSubdiv)+this->lambda*FFTconvolver.G(x,y,z)/this->CharacScaleUpdates,i,x,y,z,timeSubdiv);
  }
  
  //2) GRADIENT OF GREY LEVEL
  for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
    GradImEvo.P((J1.G(x,y,z)-this->ImEvo.G(x,y,z,timeSubdiv))+(J0.G(x,y,z)-this->ImEvo.G(x,y,z,timeSubdiv)),x,y,z,timeSubdiv);

  
}




///Update VelocityField with with the energy gradients.
///Return MaxGrad/this->RefMaxGrad
void LDM_Metamorphosis::UpdateVelocityField(int IterationNb){
  int x, y, z, i, k;
  float MaxGrad,Max_GL_Grad,MultFactor;
  double LocGrad;
  
  //1) VELOCITY FIELDS
  
  //1.1) Compute the maximum of gradient in all time frames...
  //...3D images
  MaxGrad=0;
  for (i=0;i<this->NbTimeSubdiv;i++) for (z = 1; z < this->NZ-2; z++) for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++){
    LocGrad=sqrt(pow((double)this->GradE.G(0,x,y,z,i),2.)+pow((double)this->GradE.G(1,x,y,z,i),2.)+pow((double)this->GradE.G(2,x,y,z,i),2.));
    if (MaxGrad<(float)LocGrad) MaxGrad=(float)LocGrad;
  }
  
  //...2D images
  if (this->NZ==1){
    for (i=0;i<this->NbTimeSubdiv;i++) for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++){
      LocGrad=sqrt(pow((double)this->GradE.G(0,x,y,0,i),2.)+pow((double)this->GradE.G(1,x,y,0,i),2.));
      if (MaxGrad<(float)LocGrad) MaxGrad=(float)LocGrad;
    }
  }
  
  //1.2) maximum update control at the first iteration
  if ((IterationNb==0)&&(RefMaxGrad<0.)){
    this->RefMaxGrad=MaxGrad;
    if (this->RefMaxGrad==0){
      cout << "It seems that the registered images are identical\n";
      this->RefMaxGrad=1;
    }
    cout << "\n\nRefMaxGrad is set to " << this->RefMaxGrad << ". Keep this value if you continue these\n";
    cout << "computations (using -PrefixInputs) to manage well the convergence.\n\n";
  }
  
  //1.3) compute the MultFactor
  if (MaxGrad>this->RefMaxGrad) MultFactor=this->MaxVelocityUpdate/MaxGrad;
  else MultFactor=this->MaxVelocityUpdate/(this->RefMaxGrad);
  
  //1.4) Messages
  if ((IterationNb==0)&&(MultFactor>0.01)) cout << "\nThe weight on the kernels is perhaps too low!!!\n \n";
  
  cout << " -> MaxGrad/RefMaxGrad=" << MaxGrad/this->RefMaxGrad  << "\n";
  
  //1.5) update the vector field...
  //...3D images
  for (i=0;i<this->NbTimeSubdiv;i++) for (z = 1; z < this->NZ-2; z++) for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++){
    this->VelocityField.P(this->VelocityField.G(0,x,y,z,i)+this->GradE.G(0,x,y,z,i)*MultFactor,0,x,y,z,i);
    this->VelocityField.P(this->VelocityField.G(1,x,y,z,i)+this->GradE.G(1,x,y,z,i)*MultFactor,1,x,y,z,i);
    this->VelocityField.P(this->VelocityField.G(2,x,y,z,i)+this->GradE.G(2,x,y,z,i)*MultFactor,2,x,y,z,i);
  }
  
  //...2D images
  if (this->NZ==1){
    for (i=0;i<this->NbTimeSubdiv;i++) for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++){
      this->VelocityField.P(this->VelocityField.G(0,x,y,0,i)+this->GradE.G(0,x,y,0,i)*MultFactor,0,x,y,0,i);
      this->VelocityField.P(this->VelocityField.G(1,x,y,0,i)+this->GradE.G(1,x,y,0,i)*MultFactor,1,x,y,0,i);
    }
  }
  
  
  //2) GREY LEVELS
  
  //2.1) Compute the maximum of gradient in all time frames...
  //...3D images
  
  Max_GL_Grad=0;
  for (i=0;i<this->NbTimeSubdiv;i++) for (z = 1; z < this->NZ-2; z++) for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++)
    if (Max_GL_Grad<GradImEvo.G(x,y,z,i)) Max_GL_Grad=(float)GradImEvo.G(x,y,z,i);
  
  //...2D images
  if (this->NZ==1)
    for (i=0;i<this->NbTimeSubdiv;i++) for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++)
      if (Max_GL_Grad<GradImEvo.G(x,y,0,i)) Max_GL_Grad=(float)GradImEvo.G(x,y,0,i);
  
  
  //2.2) maximum update control at the first iteration
  if ((IterationNb==0)&&(this->Ref_GL_Grad<0.)) {
    this->Ref_GL_Grad=Max_GL_Grad;
    if (this->Ref_GL_Grad==0){
      cout << "It seems that the registered images are identical" << endl;
      this->Ref_GL_Grad=1;
    }
    cout << "Ref_GL_Grad is set to " << this->Ref_GL_Grad << "." << endl;
  }
  
  //2.3) compute the MultFactor
  if (Max_GL_Grad>this->Ref_GL_Grad) MultFactor=this->Max_GL_Update/Max_GL_Grad;
  else MultFactor=this->Max_GL_Update/this->Ref_GL_Grad;
  
  //2.4) update the image...
  for (i=0;i<this->NbTimeSubdiv;i++) for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
    this->ImEvo.Add(GradImEvo.G(x,y,z,i)*MultFactor,x,y,z,i);
  
}


///save the result of the gradient descent (Beg 2005) for the current 3D image of the 4D time sequence
void LDM_Metamorphosis::SaveResultGradientDescent(void){
  //init -> compute the forward mapping and import the original input template (non pre-treated)
  CptMappingFromVeloField_IniIdMap(0,&this->VelocityField,&this->ForwardMapping);
  
  this->SaveVecDeformation(this->PrefixOutputs);
  
  //whole transformations
  this->SaveVelocityFields(&this->VelocityField,this->PrefixOutputs);
  this->SaveDeformations(this->PrefixOutputs);
  if (this->FlowLength==1) this->SaveGlobalFlowLength(this->PrefixOutputs);
  if (this->DetJacobian==1) this->SaveDetJacobian(this->PrefixOutputs);
  if (this->FinalDefInvVec==1) this->SaveInvVecDeformation(this->PrefixOutputs);
}


///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///                          FUNCTIONS TO SAVE AND LOAD THE VARIOUS STRUCTURES
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


///load the velocity fields
void LDM_Metamorphosis::LoadVelocityFields(char Prefix[256]){
  char FileNameX[256];
  char FileNameY[256];
  char FileNameZ[256];
  char VelocityField_X[256];
  char VelocityField_Y[256];
  char VelocityField_Z[256];
  
  //1) intialisation
  strcpy(FileNameX,Prefix);
  strcpy(VelocityField_X,"_VelocityField_X.nii");
  strcat(FileNameX,VelocityField_X);
  strcpy(FileNameY,Prefix);
  strcpy(VelocityField_Y,"_VelocityField_Y.nii");
  strcat(FileNameY,VelocityField_Y);
  strcpy(FileNameZ,Prefix);
  strcpy(VelocityField_Z,"_VelocityField_Z.nii");
  strcat(FileNameZ,VelocityField_Z);
  
  this->VelocityField.Read_and_Interpolate(FileNameX,FileNameY,FileNameZ,this->NX,this->NY,this->NZ,1);
}



///save the velocity fields
void LDM_Metamorphosis::SaveVelocityFields(VectorField * VelocityFieldLoc,char Prefix[256]){
  char FileNameX[256];
  char FileNameY[256];
  char FileNameZ[256];
  char VelocityField_X[256];
  char VelocityField_Y[256];
  char VelocityField_Z[256];
  
  //intialisation
  strcpy(FileNameX,Prefix);
  strcpy(VelocityField_X,"_VelocityField_X.nii");
  strcat(FileNameX,VelocityField_X);
  strcpy(FileNameY,Prefix);
  strcpy(VelocityField_Y,"_VelocityField_Y.nii");
  strcat(FileNameY,VelocityField_Y);
  strcpy(FileNameZ,Prefix);
  strcpy(VelocityField_Z,"_VelocityField_Z.nii");
  strcat(FileNameZ,VelocityField_Z);
  
  //save the velocity field
  VelocityFieldLoc->Write(FileNameX,FileNameY,FileNameZ,this->SourceFile);
}



///save the deformations in time subdivisions (not the convergence)
void LDM_Metamorphosis::SaveDeformations(char Prefix[256]){
  int TimeLoc,x, y, z;
  ScalarField Temp4DField;
  ScalarField Temp3DField;
  char FileName[256];
  char Deformations[256];
  char Metamorpo[256];
  char FinalDef[256];
  ScalarField source_image;
  
  //read the original input image of the 1st channel (with no treatments)
  source_image.Read(this->SourceFile);
  
  //intialisation
  Temp4DField.CreateVoidField(this->NX, this->NY, this->NZ,this->NbTimeSubdiv);
  strcpy(Deformations,"_VelocityDeformation.nii");
  
  Temp3DField.CreateVoidField(this->NX, this->NY, this->NZ);
  strcpy(FinalDef,"_FinalVelocityDef.nii");
  
  strcpy(Metamorpo,"_Metamorphosis.nii");
  
  //save the deformations
  for (TimeLoc=0;TimeLoc<this->NbTimeSubdiv;TimeLoc++){
    Project3Dimage(&source_image,&this->ForwardMapping,&this->J0,TimeLoc);
    
    for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
      Temp4DField.P(this->J0.G(x,y,z),x, y, z, TimeLoc);
    
    if (TimeLoc==this->NbTimeSubdiv-1)
      for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
        Temp3DField.P(this->J0.G(x,y,z),x, y, z);
  }
  
  strcpy(FileName,Prefix);
  strcat(FileName,Deformations);
  Temp4DField.Write(FileName,this->SourceFile);
  
  
  strcpy(FileName,Prefix);
  strcat(FileName,FinalDef);
  Temp3DField.Write(FileName,this->SourceFile);
  
  strcpy(FileName,Prefix);
  strcat(FileName,Metamorpo);
  ImEvo.Write(FileName,this->SourceFile);
}


///save the vector field that transforms [source] into [target]
void LDM_Metamorphosis::SaveVecDeformation(char Prefix[256]){
  int x, y, z;
  VectorField Temp3DField;
  char FileName_X[256];
  char FileName_Y[256];
  char FileName_Z[256];
  char VecDef_X[256];
  char VecDef_Y[256];
  char VecDef_Z[256];
  float flX,flY,flZ;
  float srcX,srcY,srcZ;
  float trgX,trgY,trgZ;
  float tmpX,tmpY,tmpZ;
  float tmpX2,tmpY2,tmpZ2;
  float World_Template2Target[4][4];
  
  //intialisation
  CptMappingFromVeloField_IniIdMap(0,&this->VelocityField,&this->BackwardMapping);
  
  Temp3DField.CreateVoidField(this->NX, this->NY, this->NZ);
  
  strcpy(VecDef_X,"_VecDef_X.nii");
  strcpy(VecDef_Y,"_VecDef_Y.nii");
  strcpy(VecDef_Z,"_VecDef_Z.nii");
  
  invert_4t4quaternion(this->World_Target2Template,World_Template2Target);
  
  //save the forward mapping
  for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++){
    flX=static_cast<float>(x); flY=static_cast<float>(y); flZ=static_cast<float>(z);
    
    srcX=flX*ImTemplate.Image2World[0][0]+flY*ImTemplate.Image2World[0][1]+flZ*ImTemplate.Image2World[0][2]+ImTemplate.Image2World[0][3];
    srcY=flX*ImTemplate.Image2World[1][0]+flY*ImTemplate.Image2World[1][1]+flZ*ImTemplate.Image2World[1][2]+ImTemplate.Image2World[1][3];
    srcZ=flX*ImTemplate.Image2World[2][0]+flY*ImTemplate.Image2World[2][1]+flZ*ImTemplate.Image2World[2][2]+ImTemplate.Image2World[2][3];
    
    tmpX=this->BackwardMapping.G(0,x,y,z,this->BackwardMapping.NT-1);
    tmpY=this->BackwardMapping.G(1,x,y,z,this->BackwardMapping.NT-1);
    tmpZ=this->BackwardMapping.G(2,x,y,z,this->BackwardMapping.NT-1);

    tmpX2=tmpX*ImTemplate.Image2World[0][0]+tmpY*ImTemplate.Image2World[0][1]+tmpZ*ImTemplate.Image2World[0][2]+ImTemplate.Image2World[0][3];
    tmpY2=tmpX*ImTemplate.Image2World[1][0]+tmpY*ImTemplate.Image2World[1][1]+tmpZ*ImTemplate.Image2World[1][2]+ImTemplate.Image2World[1][3];
    tmpZ2=tmpX*ImTemplate.Image2World[2][0]+tmpY*ImTemplate.Image2World[2][1]+tmpZ*ImTemplate.Image2World[2][2]+ImTemplate.Image2World[2][3];
    
    trgX=tmpX2*World_Template2Target[0][0]+tmpY2*World_Template2Target[0][1]+tmpZ2*World_Template2Target[0][2]+World_Template2Target[0][3];
    trgY=tmpX2*World_Template2Target[1][0]+tmpY2*World_Template2Target[1][1]+tmpZ2*World_Template2Target[1][2]+World_Template2Target[1][3];
    trgZ=tmpX2*World_Template2Target[2][0]+tmpY2*World_Template2Target[2][1]+tmpZ2*World_Template2Target[2][2]+World_Template2Target[2][3];
    
    Temp3DField.P(trgX-srcX,0,x,y,z);
    Temp3DField.P(trgY-srcY,1,x,y,z);
    Temp3DField.P(trgZ-srcZ,2,x,y,z);
    
  }
  
  strcpy(FileName_X,Prefix);
  strcat(FileName_X,VecDef_X);
  strcpy(FileName_Y,Prefix);
  strcat(FileName_Y,VecDef_Y);
  strcpy(FileName_Z,Prefix);
  strcat(FileName_Z,VecDef_Z);
  
  Temp3DField.Write(FileName_X,FileName_Y,FileName_Z,this->SourceFile);
}




///save the vector field that transforms [target] into [source]
void LDM_Metamorphosis::SaveInvVecDeformation(char Prefix[256]){
  int x, y, z;
  VectorField Temp3DField;
  char FileName_X[256];
  char FileName_Y[256];
  char FileName_Z[256];
  char VecDef_X[256];
  char VecDef_Y[256];
  char VecDef_Z[256];
  float flX,flY,flZ;
  float srcX,srcY,srcZ;
  float trgX,trgY,trgZ;
  float tmpX,tmpY,tmpZ;
  float tmpX2,tmpY2,tmpZ2;
  float World_Template2Target[4][4];
  
  //intialisation
  CptMappingFromVeloField_IniIdMap(this->VelocityField.NT-1,&this->VelocityField,&this->BackwardMapping);
  
  Temp3DField.CreateVoidField(this->ImTarget.NX, this->ImTarget.NY, this->ImTarget.NZ);
  
  invert_4t4quaternion(this->World_Target2Template,World_Template2Target);
  
  //save the forward mapping
  for (z = 0; z < this->ImTarget.NZ; z++) for (y = 0; y < this->ImTarget.NY; y++) for (x = 0; x < this->ImTarget.NX; x++){
    flX=static_cast<float>(x); flY=static_cast<float>(y); flZ=static_cast<float>(z);
    
    trgX=flX*ImTarget.Image2World[0][0]+flY*ImTarget.Image2World[0][1]+flZ*ImTarget.Image2World[0][2]+ImTarget.Image2World[0][3];
    trgY=flX*ImTarget.Image2World[1][0]+flY*ImTarget.Image2World[1][1]+flZ*ImTarget.Image2World[1][2]+ImTarget.Image2World[1][3];
    trgZ=flX*ImTarget.Image2World[2][0]+flY*ImTarget.Image2World[2][1]+flZ*ImTarget.Image2World[2][2]+ImTarget.Image2World[2][3];
    
    tmpX=trgX*this->World_Target2Template[0][0]+trgY*this->World_Target2Template[0][1]+trgZ*this->World_Target2Template[0][2]+this->World_Target2Template[0][3];
    tmpY=trgX*this->World_Target2Template[1][0]+trgY*this->World_Target2Template[1][1]+trgZ*this->World_Target2Template[1][2]+this->World_Target2Template[1][3];
    tmpZ=trgX*this->World_Target2Template[2][0]+trgY*this->World_Target2Template[2][1]+trgZ*this->World_Target2Template[2][2]+this->World_Target2Template[2][3];
    
    tmpX2=tmpX*ImTemplate.World2Image[0][0]+tmpY*ImTemplate.World2Image[0][1]+tmpZ*ImTemplate.World2Image[0][2]+ImTemplate.World2Image[0][3];
    tmpY2=tmpX*ImTemplate.World2Image[1][0]+tmpY*ImTemplate.World2Image[1][1]+tmpZ*ImTemplate.World2Image[1][2]+ImTemplate.World2Image[1][3];
    tmpZ2=tmpX*ImTemplate.World2Image[2][0]+tmpY*ImTemplate.World2Image[2][1]+tmpZ*ImTemplate.World2Image[2][2]+ImTemplate.World2Image[2][3];
    
    tmpX=this->BackwardMapping.G(0,tmpX2,tmpY2,tmpZ2,0);
    tmpY=this->BackwardMapping.G(1,tmpX2,tmpY2,tmpZ2,0);
    tmpZ=this->BackwardMapping.G(2,tmpX2,tmpY2,tmpZ2,0);
    
    srcX=tmpX*ImTemplate.Image2World[0][0]+tmpY*ImTemplate.Image2World[0][1]+tmpZ*ImTemplate.Image2World[0][2]+ImTemplate.Image2World[0][3];
    srcY=tmpX*ImTemplate.Image2World[1][0]+tmpY*ImTemplate.Image2World[1][1]+tmpZ*ImTemplate.Image2World[1][2]+ImTemplate.Image2World[1][3];
    srcZ=tmpX*ImTemplate.Image2World[2][0]+tmpY*ImTemplate.Image2World[2][1]+tmpZ*ImTemplate.Image2World[2][2]+ImTemplate.Image2World[2][3];
    
    
    
    Temp3DField.P(srcX-trgX,0,x,y,z);
    Temp3DField.P(srcY-trgY,1,x,y,z);
    Temp3DField.P(srcZ-trgZ,2,x,y,z);
  }
  
  strcpy(VecDef_X,"_InvVecDef_X.nii");
  strcpy(VecDef_Y,"_InvVecDef_Y.nii");
  strcpy(VecDef_Z,"_InvVecDef_Z.nii");
  strcpy(FileName_X,Prefix);
  strcat(FileName_X,VecDef_X);
  strcpy(FileName_Y,Prefix);
  strcat(FileName_Y,VecDef_Y);
  strcpy(FileName_Z,Prefix);
  strcat(FileName_Z,VecDef_Z);
  
  Temp3DField.Write(FileName_X,FileName_Y,FileName_Z,this->SourceFile);
}




///save the total length of the flow of deformation from each voxel of the image
void LDM_Metamorphosis::SaveGlobalFlowLength(char Prefix[256]){
  char VeloLength[256];
  char EvoVeloLength[256];
  
  strcpy(VeloLength,"_TotalAOD.nii");
  this->SaveFlowLength(&this->VelocityField,&this->VelocityField,this->PrefixOutputs,VeloLength);
  
  strcpy(EvoVeloLength,"EvoAOD.nii");
  this->SaveEvoFlowLength(&this->VelocityField,&this->VelocityField,this->PrefixOutputs,EvoVeloLength);
}



///By following the flow defined by the velocity field 'VeloField4Flow' PROJECT AT T=0 the contribution of
///'VeloField4Measure' in the total length of the flow from each point of the field.
/// * 'VeloField4Measure' is assumed to be part of a linear decomposition of 'VeloField4Flow'.
/// * If 'VeloField4Measure'=='VeloField4Flow' then the length of the flow defined by 'VeloField4Flow'
///   is computed.
void LDM_Metamorphosis::SaveFlowLength(VectorField * VeloField4Flow,VectorField * VeloField4Measure,char Prefix[256],char Suffix[256]){
  ScalarField LengthOfFlow;
  char FlowLength[256];
  char FileName[256];
  
  CptLengthOfFlow(VeloField4Flow,VeloField4Measure,&LengthOfFlow);
  
  
  strcpy(FlowLength,Suffix);
  strcpy(FileName,Prefix);
  strcat(FileName,FlowLength);
  LengthOfFlow.Write(FileName,this->SourceFile);
}

///By following the flow defined by the velocity field 'VeloField4Flow' FOLLOW IN TIME the contribution of
///'VeloField4Measure' in the length of the flow from each point of the field.
/// * 'VeloField4Measure' is assumed to be part of a linear decomposition of 'VeloField4Flow'.
/// * If 'VeloField4Measure'=='VeloField4Flow' then the length of the flow defined by 'VeloField4Flow'
///   is computed.
void LDM_Metamorphosis::SaveEvoFlowLength(VectorField * VeloField4Flow,VectorField * VeloField4Measure,char Prefix[256],char Suffix[256]){
  ScalarField LengthOfFlow;
  char FlowLength[256];
  char FileName[256];
  
  CptEvoLengthOfFlow(VeloField4Flow,VeloField4Measure,&LengthOfFlow);
  
  
  strcpy(FlowLength,Suffix);
  strcpy(FileName,Prefix);
  strcat(FileName,FlowLength);
  LengthOfFlow.Write(FileName,this->SourceFile);
}




///save the map of the determinant of Jacobians
void LDM_Metamorphosis::SaveDetJacobian(char Prefix[256]){
  char FileName[256];
  char StrDetJacobians[256];
  
  //compute the determinant of jacobian
  CptMappingFromVeloField_IniIdMap(this->VelocityField.NT-1,&this->VelocityField,&this->BackwardMapping);
  
  Cpt_JacobianDeterminant(&BackwardMapping,&DetJacobians,0);
  
  strcpy(StrDetJacobians,"_DetJacobian.nii");
  
  strcpy(FileName,Prefix);
  strcat(FileName,StrDetJacobians);
  DetJacobians.Write(FileName,this->SourceFile);
}





///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///                                      RUN FUNCTIONS
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



///Measure of the inverse typical amplitude of the deformations for given source
///and target images plus a simple Gaussian Kernel with a weight = 1.
float LDM_Metamorphosis::Run_MeasureTypicalAmplitude(void){
  float MaxGrad;
  double LocGrad;
  int x,y,z,i;
  
  //1) INITIALISATION
  
  //1.1) make sure that only a simple kernel with mono-channel images and no input velocity field will be used
  this->weight1=1.;
  this->weight2=0.;   this->sigmaX2=-1.; this->sigmaY2=-1.; this->sigmaZ2=-1.;
  this->weight3=0.;   this->sigmaX3=-1.; this->sigmaY3=-1.; this->sigmaZ3=-1.;
  this->weight4=0.;   this->sigmaX4=-1.; this->sigmaY4=-1.; this->sigmaZ4=-1.;
  this->weight5=0.;   this->sigmaX5=-1.; this->sigmaY5=-1.; this->sigmaZ5=-1.;
  this->weight6=0.;   this->sigmaX6=-1.; this->sigmaY6=-1.; this->sigmaZ6=-1.;
  this->weight7=0.;   this->sigmaX7=-1.; this->sigmaY7=-1.; this->sigmaZ7=-1.;
  for (i=1;i<100;i++) strcpy(this->SourceFile,"Null");
  for (i=1;i<100;i++) strcpy(this->TargetFile,"Null");
  strcpy(this->PrefixInputs,"Null");
  
  //1.2) Pre-treatment of the inuput images (grey level alignment + margins)
  this->ReadAndTreatInputImages();
  
  //1.3) Allocations of the scalar and vector fields + definition of global parameters
  this->AllocateAllVariables();
  
  //1.4) Initiate the class to smooth the images
  FFTconvolver.InitiateConvolver(this->NX,this->NY,this->NZ,1.,this->sigmaX1,this->sigmaY1,this->sigmaZ1);
  
  //2) MEASURE OF THE TYPICAL AMPLITUDE
  
  //2.1) compute the forward mapping on space
  CptMappingFromVeloField_IniIdMap(0,&this->VelocityField,&this->ForwardMapping);
  
  //2.2) compute the backward mapping on space
  CptMappingFromVeloField_IniIdMap(this->VelocityField.NT-1,&this->VelocityField,&this->BackwardMapping);
  
  //2.3) LOOP ON THE TIME SUBDIVISIONS
  //2.3.1) compute the determinant of the jacobian of the transformation
  Cpt_JacobianDeterminant(&BackwardMapping,&DetJacobians,0);
  
  //2.3.2) compute the temporary image transformed using the forward mapping from time 0 -> J0
  Project3Dimage(&this->ImTemplate,&this->ForwardMapping,&this->J0,0);
  
  //2.3.3) compute the temporary image transformed using the backward mapping from time 1 -> J1
  Project3DImageUsingAffineTransfoAndTimeDepVF(this->Template2TargetCoord,&this->ImTarget,&this->BackwardMapping,&this->J1,0);
  
  //2.3.4) compute gradient of J0
  Cpt_Grad_ScalarField(&this->J0,&this->GradJ);
  
  //2.3.5) compute the gradient of energy
  this->ComputeEnergyGradient(0,-1);
  
  //2.4) Compute the maximum of gradient in all time frames...
  //...3D images
  MaxGrad=0;
  for (z = 1; z < this->NZ-2; z++) for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++){
    LocGrad=sqrt(pow((double)this->GradE.G(0,x,y,z,0),2.)+pow((double)this->GradE.G(1,x,y,z,0),2.)+pow((double)this->GradE.G(2,x,y,z,0),2.));
    if (MaxGrad<(float)LocGrad) MaxGrad=(float)LocGrad;
  }
  
  //...2D images
  if (this->NZ==1){
    for (y = 1; y < this->NY-2; y++) for (x = 1; x < this->NX-2; x++){
      LocGrad=sqrt(pow((double)this->GradE.G(0,x,y,0,0),2.)+pow((double)this->GradE.G(1,x,y,0,0),2.));
      if (MaxGrad<(float)LocGrad) MaxGrad=(float)LocGrad;
    }
  }
  
  
  //3) RETURN THE INVERSE TYPICAL AMPLITUDE
  // the *10000 is only here for readability convenience
  
  //cout << "Typical update = " << MaxGrad/10000. << "\n";
  cout << "Inverse typical update = " << 10000./MaxGrad << "\n";
  cout << "-> Use this value as the weight of a Gaussian kernel to have the same apparent weights everywhere.\n";
  
  return 1./MaxGrad;
}





///Function to solve the registration using the gradient descent algorithm of Beg 05
void LDM_Metamorphosis::Run_Default(void){
  int IterationStopper;
  int IterationNb;
  int TimeSubdiv;
  float SqrtSSD;
  float NormaMaxGrad;  //[maximum gradient at the current iteration] / [maximum gradient at the first iteration]
  int i,x,y,z;
  float tempFl;
  
  //1) INITIALISATION
  
  //1.1) Pre-treatment of the inuput images (grey level alignment + margins)
  this->ReadAndTreatInputImages();
  
  //1.2) Allocations of the scalar and vector fields + definition of global parameters
  this->AllocateAllVariables();
  
  //1.3) Initiate the image evolution (could be simpler but OK) ...   
  //... compute null mappings
  CptMappingFromVeloField_IniIdMap(0,&this->VelocityField,&this->ForwardMapping);
  CptMappingFromVeloField_IniIdMap(this->VelocityField.NT-1,&this->VelocityField,&this->BackwardMapping);
  
  //... project the source and target images
  Project3Dimage(&this->ImTemplate,&this->ForwardMapping,&this->J0,0);
  Project3DImageUsingAffineTransfoAndTimeDepVF(this->Template2TargetCoord,&this->ImTarget,&this->BackwardMapping,&this->J1,this->NbTimeSubdiv-1);
  
  //... fill the values of ImEvo
  for (i=0;i<this->NbTimeSubdiv;i++){ 
    tempFl=static_cast<float>(this->NbTimeSubdiv-1-i)/static_cast<float>(this->NbTimeSubdiv-1);
    for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
      this->ImEvo.P(this->J0.G(x,y,z)*tempFl+this->J1.G(x,y,z)*(1-tempFl),x,y,z,i); 
  }
  
  //for (i=0;i<this->NbTimeSubdiv-1;i++) for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++) this->ImEvo.P(this->J0.G(x,y,z),x,y,z,i); 
  //for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++) this->ImEvo.P(this->J1.G(x,y,z),x,y,z,this->NbTimeSubdiv-1);
  
  
  //2) GRADIENT DESCENT
  for (IterationNb=0;IterationNb<this->iteration_nb;IterationNb++){
    cout << "Iteration Number " << IterationNb+1 << " / " << this->iteration_nb << "\n";
    
    //2.1) GRADIENTS ON THE VELOCITY FIELD AND THE GREY LEVELS
    for (TimeSubdiv=1;TimeSubdiv<this->NbTimeSubdiv-1;TimeSubdiv++){//LOOP ON THE TIME SUBDIVISIONS
      
      //2.1.1) compute the temporary image transformed using the forward mapping from time 0 -> J0
      CptMappingFromVeloField2_Init_IniIdMap(&this->Tmp3DMapping);
      
      CptMappingFromVeloField2_Increment(&this->VelocityField,&this->Tmp3DMapping,TimeSubdiv,1);
      
      for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
        this->TempImage.P(this->ImEvo.G(x,y,z,TimeSubdiv-1),x,y,z);
      
       Project3Dimage(&this->TempImage,&this->Tmp3DMapping,&this->J0,0);
      
      //2.1.2) compute the temporary image transformed using the backward mapping from time 1 -> J1
      CptMappingFromVeloField2_Init_IniIdMap(&this->Tmp3DMapping);
      
      CptMappingFromVeloField2_Increment(&this->VelocityField,&this->Tmp3DMapping,TimeSubdiv,-1);
      
      for (z = 0; z < this->NZ; z++) for (y = 0; y < this->NY; y++) for (x = 0; x < this->NX; x++)
        this->TempImage.P(this->ImEvo.G(x,y,z,TimeSubdiv+1),x,y,z);
      
       Project3Dimage(&this->TempImage,&this->Tmp3DMapping,&this->J1,0);
      
      
      //2.1.3) compute gradient of J
      Cpt_Grad_ScalarField(&this->J1,&this->GradJ);
      
      //2.4.4) compute the gradient of energy
      this->ComputeEnergyGradient(TimeSubdiv,IterationNb);
        
    }
    
    //2.4) update the velocity fields
    this->UpdateVelocityField(IterationNb);
    
  }
  //3) SAVE THE RESULTS
  CptMappingFromVeloField_IniIdMap(0,&this->VelocityField,&this->ForwardMapping);
  CptMappingFromVeloField_IniIdMap(this->VelocityField.NT-1,&this->VelocityField,&this->BackwardMapping);
  this->SaveResultGradientDescent();
}



///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
///                                        MAIN RUN FUNCTION 
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


///run function
void LDM_Metamorphosis::Run(void)
{
  if (this->MeasureTypicAmp!=1)
    this->Run_Default();
  else
    this->Run_MeasureTypicalAmplitude();
}

